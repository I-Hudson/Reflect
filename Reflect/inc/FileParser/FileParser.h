#pragma once

#include "Core/Core.h"
#include "ReflectStructs.h"
#include <string>
#include <fstream>
#include <unordered_map>
#include <tuple>

namespace Reflect
{
	/// <summary>
	/// Parse a single file. This should extract all the info like functions and variables.
	/// </summary>
	class FileParser
	{
	public:
		FileParser();
		~FileParser();

		void ParseDirectory(const std::string& directory);
		void SetIgnoreStrings(const std::vector<std::string>& ignoreStrings);

		const FileParsedData& GetFileParsedData(int index) const { return m_filesParsed.at(index); }
		const std::vector<FileParsedData>& GetAllFileParsedData() const { return m_filesParsed; }

	private:
		std::ifstream OpenFile(const std::string& filePath);
		void CloseFile(std::ifstream& file);

		bool CheckExtension(const std::string& filePath, std::vector<const char*> extensions);
		bool CheckIfAutoGeneratedFile(const std::string& filePath);

		FileParsedData LoadFile(std::ifstream& file);


		bool ParseFile(FileParsedData& fileData);
		bool ReflectContainerHeader(FileParsedData& fileData, const std::string& keyword, const EReflectType type);
		void ReflectContainer(FileParsedData& fileData);

		int FindEndOfConatiner(const FileParsedData& fileData);
		std::vector<std::string> ReflectFlags(FileParsedData& fileData);

		char FindNextChar(FileParsedData& fileData, const std::vector<char>& ignoreChars);
		char FindNextChar(FileParsedData const& fileData, int& cursor, const std::vector<char>& ignoreChars);
		char FindNextChar(FileParsedData& fileData, char charToFind);

		std::string FindNextWord(FileParsedData& fileData, const std::vector<char>& endChars);
		bool IsWordReflectKey(std::string_view view);

		bool CheckForTypeAlias(std::string_view view);
		bool CheckForVisibility(std::string_view view);
		bool CheckForConstructor(FileParsedData& fileData, ReflectContainerData& container, std::string_view view);
		bool CheckForIgnoreWord(FileParsedData& fileData, std::string_view view);
		void RemoveComments(FileParsedData& fileData, std::string& line);

		void GetReflectNameAndReflectValueTypeAndReflectModifer(std::string& str, std::string& name, EReflectValueType& valueType, EReflectValueModifier& modifer);

		ReflectFunctionData GetFunction(FileParsedData& fileData, const std::vector<std::string>& flags);
		ReflectMemberData GetMember(FileParsedData& fileData, const std::vector<std::string>& flags);

		void SkipFunctionBody(FileParsedData& fileData);

		EReflectType CheckForReflectType(FileParsedData& data);

		bool CheckForEndOfFile(FileParsedData& fileData, int cursor);
		EReflectValueType CheckForRefOrPtr(std::string_view view);
		EReflectValueModifier CheckForMemberModifers(std::string_view view);

		std::vector<ReflectTypeNameData> ReflectGetFunctionParameters(std::string_view view);

#ifndef EXP_PARSER
		bool RefectCheckForEndOfLine(const FileParsedData& fileData);
		bool ReflectTypeCheck(const std::string& type);

		std::tuple<std::string, std::string, bool> ReflectTypeAndName(FileParsedData& fileData, const std::vector<char>& endOfLineCharacters);
		void CheckForConst(FileParsedData& fileData, std::string& type, bool& typeFound, bool& isConst);

#endif
		int CountNumberOfSinceTop(const FileParsedData& fileData, int cursorStart, const char& character);
	private:
		std::vector<FileParsedData> m_filesParsed;
		std::vector<std::string> m_filesToRemove;
		std::vector<std::string> m_ignoreStrings;
	};
}
