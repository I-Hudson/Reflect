#include "CodeGenerate/CodeGenerateSource.h"
#include "Instrumentor.h"
#include "CodeGenerate/CodeGenerateHeader.h"

namespace Reflect
{
	void CodeGenerateSource::GenerateSource(const FileParsedData& data, std::ofstream& file, const ReflectAddtionalOptions& addtionalOptions)
	{
		REFLECT_PROFILE_FUNCTION();

		file << " // This file is auto generated by the Reflect tool please don't modify this file as it will be overwritten." << NEW_LINE();

		//CodeGenerate::IncludeHeader(data.FileName + ReflectFileGeneratePrefix + ".h", file);
		if (!addtionalOptions.options.at(Reflect_CMD_Option_PCH_Include).empty())
		{
			CodeGenerate::IncludeHeader(addtionalOptions.options.at(Reflect_CMD_Option_PCH_Include), file);
		}
		CodeGenerate::IncludeHeader("../" + data.FileName + ".h", file);
		file << NEW_LINE();

		for (const std::string& include : data.CPPIncludes)
		{
			CodeGenerate::IncludeHeader(include, file);
		}
		file << NEW_LINE();

		for (auto& reflectData : data.ReflectData)
		{
#ifdef REFLET_TYPE_INFO
			WriteGenerateTypeInfo(reflectData, file, addtionalOptions);
#else
			WriteMemberProperties(reflectData, file, addtionalOptions);
			WriteFunctionGet(reflectData, file, addtionalOptions);
			WriteMemberGet(reflectData, file, addtionalOptions);
#endif
		}
	}

	void CodeGenerateSource::WriteMemberProperties(const ReflectContainerData& data, std::ofstream& file, const ReflectAddtionalOptions& addtionalOptions)
	{
		auto getMemberProps = [](const std::vector<std::string>& flags) -> std::string
		{
			if (flags.size() == 0)
			{
				return "{ }";
			}

			std::string value;
			value += "{";
			for (auto const& flag : flags)
			{
				if (flag != flags.back())
				{
					value += "\"" + flag + "\"" + ", ";
				}
			}
			value += "\"" + flags.back() + "\"" + "}";
			return value;
		};

		if (data.Members.size() > 0)
		{
			file << "Reflect::ReflectMemberProp " + data.Name + "::__REFLECT_MEMBER_PROPS__[" + std::to_string(data.Members.size()) + "] = {" << NEW_LINE();
			for (const auto& member : data.Members)
			{
				file << "\tReflect::ReflectMemberProp(\"" + member.Name + 
					"\", new Reflect::ReflectTypeCPP<" + CodeGenerateHeader::GetType(member, false) + ">(Reflect::EReflectType::Member), " +
					 "__REFLECT__" + member.Name + "(), " + 
					getMemberProps(member.ContainerProps) + ")," << NEW_LINE();
			}
			file << "};\n" << NEW_LINE();
		}
	}

	void CodeGenerateSource::WriteMemberGet(const ReflectContainerData& data, std::ofstream& file, const ReflectAddtionalOptions& addtionalOptions)
	{
		file << "Reflect::ReflectMember " + data.Name + "::GetMember(const char* memberName)\n{" << NEW_LINE();
		if (data.Members.size() > 0)
		{
			file << "\tfor(const auto& member : __REFLECT_MEMBER_PROPS__)\n\t{" << NEW_LINE();
			file << "\t\tif(memberName == member.Name)" << NEW_LINE();
			file << "\t\t{" << NEW_LINE();
			file << "\t\t\t//CheckFlags" << NEW_LINE();
			file << "\t\t\treturn " + MemberFormat() + "; " << NEW_LINE();
			file << "\t\t}" << NEW_LINE();
			file << "\t}" << NEW_LINE();
		}
		file << "\treturn __super::GetMember(memberName);" << NEW_LINE();
		file << "}\n" << NEW_LINE();

		file << "std::vector<Reflect::ReflectMember> " + data.Name + "::GetMembers(std::vector<std::string> const& flags)\n{" << NEW_LINE();
		file << "\tstd::vector<Reflect::ReflectMember> members = __super::GetMembers(flags);" << NEW_LINE();
		if (data.Members.size() > 0)
		{
			file << "\tfor(auto& member : __REFLECT_MEMBER_PROPS__)\n\t{" << NEW_LINE();
			file << "\t\tif(member.ContainsProperty(flags))" << NEW_LINE();
			file << "\t\t{" << NEW_LINE();
			file << "\t\t\tmembers.push_back(" + MemberFormat() + "); " << NEW_LINE();
			file << "\t\t}" << NEW_LINE();
			file << "\t}" << NEW_LINE();
		}
		file << "\treturn members;" << NEW_LINE();
		file << "}\n" << NEW_LINE();

		file << "std::vector<Reflect::ReflectMember> " + data.Name + "::GetAllMembers()\n{" << NEW_LINE();
		file << "\tstd::vector<Reflect::ReflectMember> members = __super::GetAllMembers();" << NEW_LINE();
		if (data.Members.size() > 0)
		{
			file << "\tfor(auto& member : __REFLECT_MEMBER_PROPS__)\n\t{" << NEW_LINE();
			file << "\t\tmembers.push_back(" + MemberFormat() + "); " << NEW_LINE();
			file << "\t}" << NEW_LINE();
		}
		file << "\treturn members;" << NEW_LINE();
		file << "}\n" << NEW_LINE();
	}

	void CodeGenerateSource::WriteFunctionGet(const ReflectContainerData& data, std::ofstream& file, const ReflectAddtionalOptions& addtionalOptions)
	{
		file << "Reflect::ReflectFunction " + data.Name + "::GetFunction(const char* functionName)\n{" << NEW_LINE();
		for (const auto& func : data.Functions)
		{
			file << "\tif(functionName == \"" + func.Name + "\")" << NEW_LINE();
			file << "\t{" << NEW_LINE();
			file << "\t\treturn Reflect::ReflectFunction(this, " + data.Name + "::__REFLECT_FUNC__" + func.Name + ");" << NEW_LINE();
			file << "\t}" << NEW_LINE();
		}
		file << "\treturn __super::GetFunction(functionName);" << NEW_LINE();
		file << "}\n" << NEW_LINE();
	}

#ifdef REFLET_TYPE_INFO
	void CodeGenerateSource::WriteGenerateTypeInfo(const ReflectContainerData& data, std::ofstream& file, const ReflectAddtionalOptions& addtionalOptions)
	{
		file << "template<>" << NEW_LINE();
		file << "class Reflect::GenerateTypeInfoForType<" + data.Name + ">\n{" << NEW_LINE();
		file << "public:" << NEW_LINE();
		file << "\tReflect::ReflectTypeInfo GetTypeInfo(" + data.Name + "* ownerClass)\n\t{" << NEW_LINE();
		file << "\t\tstd::vector<std::unique_ptr<Reflect::ReflectTypeFunction>> functions = GenerateFunctions(ownerClass);" << NEW_LINE();
		file << "\t\tstd::vector<std::unique_ptr<Reflect::ReflectTypeMember>> members = GenerateMembers(ownerClass);" << NEW_LINE();
		file << "\t\treturn ReflectTypeInfo(ownerClass, ";
		file << "std::make_unique<ReflectTypeCPP<" + data.Name + ">>(Reflect::EReflectType::Class), ";
		file << "std::move(members), ";
		file << "std::move(functions)); " << NEW_LINE();
		file << "\t}" << NEW_LINE();
		WRITE_PRIVATE();
		WriteGenerateTypeMembers(data, file, addtionalOptions);
		WriteGenerateTypeFunctions(data, file, addtionalOptions);
		file << "};\n" << NEW_LINE();

		file << "Reflect::ReflectTypeInfo " + data.Name + "::GetTypeInfo()\n{" << NEW_LINE();
		file << "\treturn Reflect::GenerateTypeInfoForType<" + data.Name + ">().GetTypeInfo(nullptr);" << NEW_LINE();
		file << "}\n" << NEW_LINE();
		file << "Reflect::ReflectTypeInfo " + data.Name + "::GetTypeInfo(" + data.Name + "* classPtr)\n{" << NEW_LINE();
		file << "\treturn Reflect::GenerateTypeInfoForType<" + data.Name + ">().GetTypeInfo(classPtr);" << NEW_LINE();
		file << "}\n" << NEW_LINE();
	}

	void CodeGenerateSource::WriteGenerateTypeMembers(const ReflectContainerData& data, std::ofstream& file, const ReflectAddtionalOptions& addtionalOptions)
	{
		file << "\tstd::vector<std::unique_ptr<Reflect::ReflectTypeMember>> GenerateMembers(" + data.Name + "* ownerClass)\n\t{" << NEW_LINE();
		file << "\t\tstd::vector<std::unique_ptr<Reflect::ReflectTypeMember>> members;\n" << NEW_LINE();
		for (const auto& member : data.Members)
		{
			file << "\t\tmembers.emplace_back(std::make_unique<Reflect::ReflectTypeMember>(ownerClass, (unsigned char*)ownerClass + offsetof(" + data.Name + ", " + member.Name + "), ";
			file << "std::make_unique<ReflectTypeCPP<" + member.RawType + ">>(Reflect::EReflectType::Member, \"" + member.Name + "\")));" << NEW_LINE();
		}
		file << "\t\treturn members;" << NEW_LINE();
		file << "\t}" << NEW_LINE();
	}

	void CodeGenerateSource::WriteGenerateTypeFunctions(const ReflectContainerData& data, std::ofstream& file, const ReflectAddtionalOptions& addtionalOptions)
	{
		auto generateFunctionArgs = [&data]()->std::string
		{
			auto generateSingleArg = [&data](const ReflectTypeNameData& arg) -> std::string
			{
				std::string str;
				str += "std::make_unique<ReflectTypeCPP<" + arg.RawType + ">>(Reflect::EReflectType::Parameter, \"" + arg.Name + "\")";
				return str;
			};

			std::string str;

			for (const auto& func : data.Functions)
			{
				str += "\t\tstd::vector<std::unique_ptr<ReflectType>> " + func.Name + "_Args;" + NEW_LINE();
				for (const auto& arg : func.Parameters)
				{
					str += "\t\t" + func.Name + "_Args.emplace_back(" + generateSingleArg(arg) + ");" + NEW_LINE();
				}
			}
			return str;
		};

		auto generateSingleFunction = [&data](const ReflectFunctionData& func) -> std::string
		{
			std::string str;
			str += "std::make_unique<Reflect::ReflectTypeFunction>";
			str += "((void*)ownerClass, ";
			str += data.Name + "::__REFLECT_FUNC__" + func.Name + ", ";
			str += "std::make_unique<ReflectTypeCPP<" + func.Type + ">>(Reflect::EReflectType::Function, \"" + func.Name + "\"), ";
			str += "std::move(" + func.Name + "_Args))";
			return str;
		};

		file << "\tstd::vector<std::unique_ptr<Reflect::ReflectTypeFunction>> GenerateFunctions(" + data.Name + "* ownerClass)\n\t{" << NEW_LINE();

		file << generateFunctionArgs() + NEW_LINE();

		file << "\t\tstd::vector<std::unique_ptr<Reflect::ReflectTypeFunction>> funcs;" << NEW_LINE();
		for (const auto& f : data.Functions)
		{
			file << "\t\tfuncs.push_back(" + generateSingleFunction(f) + ");" << NEW_LINE();
		}
		file << "\t\treturn funcs;" << NEW_LINE();
		file << "\t}" << NEW_LINE();
	}
#endif

	std::string CodeGenerateSource::MemberFormat()
	{
		return "Reflect::ReflectMember(member.Name, member.Type, ((char*)this) + member.Offset)";
	}

	//void CodeGenerateSource::WriteFunctionBindings(const ReflectContainerData& data, std::ofstream& file)
	//{
	//	file << "\t" + data.Name << "* ptr = dynamic_cast<" + data.Name + "*>(this);" << NEW_LINE();
	//	file << "\tassert(ptr != nullptr && \"[" + data.Name + ContainerPrefix + "::" + "SetupReflectBindings()] 'ptr' should not be null.\");\n" << NEW_LINE();
	//	for (auto& func : data.Functions)
	//	{
	//		// Write to the auto generated file binding a function then setting up a "FuncWrapper" for which we can then call the function from.
	//		file << "\tauto " + func.Name + "Func = std::bind(&" + data.Name + "::" + func.Name + ", ptr);" << NEW_LINE();
	//		file << "\tReflect::FuncWrapper " + func.Name + "Wrapper(" + func.Name + "Func);" << NEW_LINE();
	//		file << "\t__super::AddFunction(" + func.Name + ", " + func.Name + "Wrapper);" << NEW_LINE();
	//	}
	//	file << NEW_LINE();
	//}
}
