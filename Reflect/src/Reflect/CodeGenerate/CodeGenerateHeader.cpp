#include "Reflect/CodeGenerate/CodeGenerateHeader.h"
#include "Reflect/CodeGenerate/CodeGenerate.h"
#include "Reflect/CodeGenerate/CG_Utils.h"

#include "Reflect/Core/Core.h"

#include "Reflect/Instrumentor.h"

#include <assert.h>

namespace Reflect::CodeGeneration
{
	std::string GetCurrentFileID(const std::string& containerName, const std::string& fileName)
	{
#ifdef REFLECT_SINGLE_FILE
		return  containerName + "_Source_h";

#else
		return  fileName + "_Source_h";
#endif
	}

#define WRITE_CURRENT_FILE_ID(ContainerName, FileName) file << "#define " + GetCurrentFileID(ContainerName, FileName)

	void CodeGenerateHeader::GenerateHeader(const Parser::FileParsedData& data, std::ofstream& file, const ReflectAddtionalOptions* additionalOptions)
	{
		REFLECT_PROFILE_FUNCTION();

		file << " // This file is auto generated by the Reflect tool please don't modify this file as it will be overwritten.\n";

		CodeGenerate::IncludeHeader("Reflect/ReflectStructs.h", file);
		CodeGenerate::IncludeHeader("Reflect/Core/Util.h", file);

		file << "\n";
		file << "#ifdef " + data.FileName + Keys::ReflectFileGeneratePrefix + "_h\n";
		file << "#error \"" + data.FileName + Keys::ReflectFileGeneratePrefix + ".h" + " already included, missing 'pragma once' in " + data.FileName + ".h\"\n";
		file << "#endif " + data.FileName + Keys::ReflectFileGeneratePrefix + "_h\n";
		file << "#define " + data.FileName + Keys::ReflectFileGeneratePrefix + "_h\n\n";

		WriteMacros(data, file, additionalOptions);
	}

	void CodeGenerateHeader::WriteMacros(const Parser::FileParsedData& data, std::ofstream& file, const ReflectAddtionalOptions* additionalOptions)
	{
		REFLECT_PROFILE_FUNCTION();
		for (const auto& reflectData : data.ReflectData)
		{
			CG_Utils::WriteIfDefines(reflectData, file);

			const std::string CurrentFileId = GetCurrentFileID(reflectData.Name, data.FileName) + "_" + std::to_string(reflectData.ReflectGenerateBodyLine);

#ifdef REFLECT_TYPE_INFO_ENABLED
			m_CGHeaderTypeInfo.WriteGenerateTypeInfo(reflectData, file, CurrentFileId, additionalOptions);
#else
			m_CGHeaderLegacy.WriteGeneratedData(reflectData, file, CurrentFileId, additionalOptions);
#endif 

			WRITE_CURRENT_FILE_ID(reflectData.Name, data.FileName) + "_" + std::to_string(reflectData.ReflectGenerateBodyLine) + "_GENERATED_BODY \\\n";

#ifdef REFLECT_TYPE_INFO_ENABLED
			m_CGHeaderTypeInfo.WriteClosingMacro(file, CurrentFileId);
#else
			m_CGHeaderLegacy.WriteClosingMacro(file, CurrentFileId);
#endif
			file << CurrentFileId + "_FUNCTION_DECLARE" + NEW_LINE_SLASH;
			file << NEW_LINE <<  NEW_LINE;
			CG_Utils::WriteEndIfDefines(reflectData, file);
			WRITE_CLOSE;
		}

#ifndef REFLECT_SINGLE_FILE
		file << "#undef CURRENT_FILE_ID\n";
		file << "#define CURRENT_FILE_ID " + GetCurrentFileID("", data.FileName) + "\n";
#endif
	}


}