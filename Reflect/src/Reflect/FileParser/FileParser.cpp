#include "Reflect/FileParser/FileParser.h"
#include "Reflect/FileParser/FileParserKeyWords.h"

#include "Reflect/Core/Defines.h"
#include "Reflect/Core/Core.h"
#include "Reflect/Core/Util.h"
#include "Reflect/Instrumentor.h"

#include <sstream>
#include <vector>
#include <iostream>
#include <filesystem>
#include <stack>
#include <assert.h>
#include <string.h>
#include <functional>

#define EXP_PARSER
// Load files using multiple threads (Testing shows this doesn't increase performance, disabled by default).
#define PARSER_LOAD_FILES_MULTITHREADED 0
// Load and Parse files using multiple threads (Disabled by default).
#define FILE_PARSER_MULTITHREADED 0
#ifndef FILE_PARSER_COLLECT_ALL_CONTAINERS
/* 
* Parse all classes and structs found in any file regardless if there is a REFLECT_[CLASS / STRUCT] macro for it (Enabled by default).
* This improves namespace resolving and linking objects which are not defined with their full namespace. 
* Example: If a member variable is defined as Vector2, but the Vector2 class is defined within namespace Maths, Reflect by default
* can't link these. There are two options:
	1. The first option is to use the REFLCET_CLASS macro with REFELCT_LOOKUP_ONLY, which always reflect to find the Vector2 class
	then parse the namespace it is within knowing about the object.
	2. The second option is to enable 'FILE_PARSER_COLLECT_ALL_CONTAINERS' (this define is enabled by default). With this option enabled
	reflect will scan all files within the directory given for all classes/structs and track them (as if they all had 'REFLCET_CLASS(REFELCT_LOOKUP_ONLY)' macro).
	This always the user of Reflect to not have 'REFLCET_CLASS(REFELCT_LOOKUP_ONLY)' implemented throughout the code base while allowing Reflect to  accurate link objects
	which have been defined with part of their overall namespaces.

* It is recommanded not to define 'FILE_PARSER_COLLECT_ALL_CONTAINERS' unless there are issues as the default value of 'FILE_PARSER_COLLECT_ALL_CONTAINERS' is enabled.
*/
#define FILE_PARSER_COLLECT_ALL_CONTAINERS 1
#endif

namespace Reflect::Parser
{
	constexpr size_t DEFAULT_TYPE_SIZE = 0;

	const std::vector<char> emptyChars = { '\n', '\t', '\r', ' ' };
	const std::vector<char> generalEndChars = { ' ', '(', '=', ';', ':'};
	const std::vector<char> functionStartChars = { '(' };
	const std::vector<char> memberStartChars = { '=', ';' };

	FileParser::FileParser()
	{ }

	FileParser::~FileParser()
	{ }

	void FileParser::ParseDirectory(const std::string& directory, const ReflectAddtionalOptions* options, FileParserOptions fileParserOptions)
	{
		REFLECT_PROFILE_FUNCTION();

		m_options = options;
		m_toalNumberOfContainersParsed = 0;
		m_toalNumberOfContainersToGenerateCode = 0;

		m_directoriesParsed.push_back(directory);
		std::filesystem::path dirPath(directory);
		std::error_code err;
		if (!std::filesystem::is_directory(dirPath, err))
		{
			Log_Error("Path is not a directory '%s'. Err: '%s'.\n", dirPath.c_str(), err.message().c_str());
			return;
		}

		std::mutex filesLoadedMutex;
		std::vector<FileParsedData> filesLoaded;
		std::vector<std::thread> fileLoadingThreads;

		{
			REFLECT_PROFILE_SCOPE("Iterator Over Directory");
			for (const auto& f : std::filesystem::recursive_directory_iterator(directory))
			{
				std::string filePath = f.path().u8string();

				if ((f.is_regular_file() || f.is_character_file()) &&
					CheckExtension(filePath, { ".h", ".hpp" }) &&
					!CheckIfAutoGeneratedFile(filePath))
				{
					Log_Info("Loading File: '%s'.\n", filePath.c_str());
#if FILE_PARSER_MULTITHREADED || PARSER_LOAD_FILES_MULTITHREADED
					// Load files off the main thread. In testing with 'Insight' this was slower than running one a single thread.
					std::thread fileToLoadThread = std::thread([&](const std::filesystem::path fsPath)
					{
						REFLECT_PROFILE_SCOPE("Load File Thread");
						std::string filePath = fsPath.u8string();

						std::ifstream file = OpenFile(filePath);
						FileParsedData data = LoadFile(file);
						data.FileName = fsPath.filename().u8string().substr(0, fsPath.filename().u8string().find_last_of('.'));
						data.FilePath = fsPath.parent_path().u8string();
						data.parserOptions = fileParserOptions;
						CloseFile(file);

#if FILE_PARSER_MULTITHREADED
						ParseFile(data);
						{
							std::lock_guard l(filesLoadedMutex);
							m_filesParsed.push_back(data);
						}
#else
						std::lock_guard l(filesLoadedMutex);
						filesLoaded.push_back(data);
#endif
					}, f);

					fileLoadingThreads.push_back(std::move(fileToLoadThread));

#else
					// TODO thread this. We could load files on more than one thread to speed
					// this up.
					REFLECT_PROFILE_SCOPE("Load File");
					std::ifstream file = OpenFile(filePath);
					FileParsedData data = LoadFile(file);

					data.FullPath = f.path().u8string();
					data.FileName = f.path().filename().u8string().substr(0, f.path().filename().u8string().find_last_of('.'));
					data.FilePath = f.path().parent_path().u8string();

					data.parserOptions = fileParserOptions;
					filesLoaded.push_back(data);
					CloseFile(file);
#endif
				}
			}
		}

#if FILE_PARSER_MULTITHREADED || PARSER_LOAD_FILES_MULTITHREADED
		{
			REFLECT_PROFILE_SCOPE("Wait For All File Loading Threads To Complete");

			// Wait for all threads to complete.
			for (size_t threadIdx = 0; threadIdx < fileLoadingThreads.size(); threadIdx++)
			{
				fileLoadingThreads[threadIdx].join();
			}
		}
#endif

#if FILE_PARSER_MULTITHREADED == 0
		// All files have been loaded.
		// Now we need to parse them to find all the information we want from them.
		// TODO: this could also be threaded.
		{
			Log::ProgressBar parseFilesProgress(filesLoaded.size(), "Files Parsed", Log::ProgressBar::Options::All);
			uint32_t progressBarCount = 0;
			parseFilesProgress.SetProgress(progressBarCount);

			REFLECT_PROFILE_SCOPE("Parse File");
			for (auto& file : filesLoaded)
			{
				parseFilesProgress.SetPostText("Current File '" + file.FileName + "'");
				parseFilesProgress.SetProgress(++progressBarCount);
				ParseFile(file);
				m_filesParsed.push_back(file);
			}
		}
#endif

		{
			Log::ProgressBar parseUsingTagsProgress(m_filesParsed.size(), "Files Parsed For Using/Typedefs", Log::ProgressBar::Options::All);
			uint32_t progressBarCount = 0;
			parseUsingTagsProgress.SetProgress(progressBarCount);

			REFLECT_PROFILE_SCOPE("Parse Using Tags");
			for (auto& file : m_filesParsed)
			{
				parseUsingTagsProgress.SetPostText("Current File '" + file.FileName + "'");
				parseUsingTagsProgress.SetProgress(++progressBarCount);
				ParseUsingTags(file);
			}
		}

		Log_Info("[FileParser::ParseDirectory] Total number of containers parsed: '%d'.\n", m_toalNumberOfContainersParsed);
		Log_Info("[FileParser::ParseDirectory] Total number of files parsed: '%d'.\n", m_filesParsed.size());

		ResolveNamespaces();
		LinkAllInheritances();
		RemoveLookupOnlyContainers();

		Log_Info("[FileParser::ParseDirectory] Total number of containers removed: '%d'.\n", m_toalNumberOfContainersParsed - m_toalNumberOfContainersToGenerateCode);
		Log_Info("[FileParser::ParseDirectory] Total number of containers to generate code for: '%d'.\n", m_toalNumberOfContainersToGenerateCode);
	}

	void FileParser::Clear()
	{
		m_filesParsed.clear();
	}

	void FileParser::SetIgnoreStrings(const std::vector<std::string>& ignoreStrings)
	{
		REFLECT_PROFILE_FUNCTION();
		m_ignoreStrings = ignoreStrings;
	}

	std::ifstream FileParser::OpenFile(const std::string& filePath)
	{
		REFLECT_PROFILE_FUNCTION();
		std::ifstream file = std::ifstream(filePath);
		assert(file.is_open() && "[FileParser::OpenFile] File is not open.");
		return file;
	}

	void FileParser::CloseFile(std::ifstream& file)
	{
		if (file.is_open())
		{
			file.close();
		}
	}

	bool FileParser::CheckExtension(const std::string& filePath, std::vector<const char*> extensions)
	{
		REFLECT_PROFILE_FUNCTION();
		std::string extension = filePath.substr(filePath.find_last_of('.'));
		for (auto& e : extensions)
		{
			if (e == extension)
			{
				return true;
			}
		}
		return false;
	}

	bool FileParser::CheckIfAutoGeneratedFile(const std::string& filePath)
	{
		REFLECT_PROFILE_FUNCTION();
		return filePath.find(Keys::ReflectFileGeneratePrefix) != std::string::npos;
	}

	FileParsedData FileParser::LoadFile(std::ifstream& file)
	{
		REFLECT_PROFILE_FUNCTION();
		FileParsedData data = {};

		file.seekg(0, std::ios::end);
		size_t fileSize = static_cast<size_t>(file.tellg());
		file.seekg(0, std::ios::beg);
		data.Data = std::string(fileSize, '\0');
		data.Cursor = 0;
		file.read(&data.Data[0], fileSize);

		return data;
	}

	bool FileParser::ParseFile(FileParsedData& fileData)
	{
		REFLECT_PROFILE_FUNCTION();
		REFLECT_PROFILE_SCOPE_CSTR(fileData.FileName.data());

		if (fileData.Parsed)
		{
			return !fileData.ReflectData.empty();
		}

		bool reflectItem = false;

#if FILE_PARSER_COLLECT_ALL_CONTAINERS
		do
		{
			const uint64_t nextContainerIdx = FindNextContainer(fileData);
			if (nextContainerIdx == -1)
			{
				// There is no class/struct. 
				break;
			}

			const uint64_t nextReflectContainerIdx = FindNextReflectContainer(fileData);
			const bool containerToBeReflected = nextReflectContainerIdx < nextContainerIdx;
			if (containerToBeReflected)
			{
				fileData.ReflectData.back().GenerateReflectCode = true;
				fileData.Cursor = nextReflectContainerIdx;
				if (!ParseContainerReflectProperties(fileData))
				{
					Log_Error("[FileParser::ParseFile] Unable to parse reflect properties for object in file: '%s'.\n", fileData.FullPath.c_str());
					fileData.ReflectData.pop_back();
					continue;
				}
			}
			else
			{
				fileData.ReflectData.back().GenerateReflectCode = false;
			}

			if (!ParseContainerHeader(fileData))
			{
				fileData.ReflectData.pop_back();
				continue;
			}

			if (containerToBeReflected)
			{
				ReflectContainer(fileData);
				if (fileData.AbortParsing)
				{
					Log_Error("[FileParser::ParseFile] Something has gone wrong parsing file '%s'. All reflect data has been removed. Please fix issues.\n", fileData.FullPath.data());
					fileData.ReflectData.clear();
				}
				GetAllCPPIncludes(fileData);
				reflectItem = true;
			}

			++m_toalNumberOfContainersParsed;

			if (!fileData.AbortParsing)
			{
				fileData.ReflectData.back().HasBeenParsed = true;
			}

		} while (fileData.Cursor != fileData.Data.size());

		if (!fileData.ReflectData.empty() && !fileData.ReflectData.back().HasBeenParsed)
		{
			fileData.ReflectData.pop_back();
		}
#else
		while (true)
		{
			EReflectType reflectType = EReflectType::Unknown;
			const uint64_t reflectContainerIdx = FindNextReflectContainer(fileData, &reflectType);
			if (reflectContainerIdx == -1)
			{
				break;
			}

			fileData.Cursor = reflectContainerIdx;
			ReflectContainerData& reflectData = fileData.ReflectData.emplace_back(ReflectContainerData());
			reflectData.ReflectType = reflectType;
			reflectData.GenerateReflectCode = true;

			if (!ParseContainerReflectProperties(fileData))
			{
				Log_Error("[FileParser::ParseFile] Unable to parse reflect properties for object in file: '%s'.\n", fileData.FullPath.c_str());
				fileData.ReflectData.pop_back();
				continue;
			}

			if (!ParseContainerHeader(fileData))
			{
				fileData.ReflectData.pop_back();
				continue;
			}

			ReflectContainer(fileData);
			if (fileData.AbortParsing)
			{
				Log_Error("[FileParser::ParseFile] Something has gone wrong parsing file '%s'. All reflect data has been removed. Please fix issues.\n", fileData.FullPath.data());
				fileData.ReflectData.clear();
			}
			GetAllCPPIncludes(fileData);
			reflectItem = true;

			++m_toalNumberOfContainersParsed;
		}
#endif
		fileData.Parsed = true;
		return reflectItem;
	}

	void FileParser::ParseUsingTags(FileParsedData& fileData)
	{
		REFLECT_PROFILE_FUNCTION();
		REFLECT_PROFILE_SCOPE_CSTR(fileData.FileName.data());

		fileData.Cursor = 0;
		if (fileData.ReflectData.empty())
		{
			return;
		}
		
		while (fileData.Cursor < fileData.Data.size())
		{
			fileData.Cursor = fileData.Data.find(Keys::UsingKey, fileData.Cursor);
			if (fileData.Cursor != std::string::npos)
			{
				if (IsCursorWithinComment(fileData, fileData.Cursor, true))
				{
					continue;
				}

				std::vector<std::string> aliasNamespaceSplit = FindAllNamespaces(fileData, fileData.Cursor);
				std::string aliasNamespace;
				for (size_t i = 0; i < aliasNamespaceSplit.size(); i++)
				{
					aliasNamespace += aliasNamespaceSplit[i] + "::";
				}

				if (fileData.FileName == "AudioComponent")
				{
					int i = 4;
				}

				const uint64_t strStart = fileData.Cursor;
				FindNextChar(fileData, ';');

				const uint64_t strCount = fileData.Cursor - strStart - strlen(Keys::UsingKey);
				std::string str = fileData.Data.substr(strStart + strlen(Keys::UsingKey), strCount);
				if (!str.empty() && str.back() == ';')
				{
					str.pop_back();
				}

				std::string alias = str.substr(0, str.find('='));
				std::string type = str.substr(str.find('=') + 1);

				Util::RemoveCharAll(alias, ' ');
				Util::RemoveCharAll(type, ' ');

				bool foundValidContainerReference = false;

				const uint64_t typeTemplateStart = type.find('<');
				const uint64_t typeTemplateEnd = type.find('>');
				const bool isTempalte = typeTemplateStart != std::string::npos && typeTemplateEnd != std::string::npos;
				if (isTempalte)
				{
					const std::string templateTypeBase = type = type.substr(0, typeTemplateStart);
					const ReflectContainerData* templateTypeData = FindReflectContainerData(templateTypeBase);
					if (templateTypeData)
					{
						TypeAliasMap[alias].push_back(templateTypeBase);
						foundValidContainerReference = true;
					}
				}
				else
				{
					const ReflectContainerData* typeData = FindReflectContainerData(type);
					if (typeData)
					{
						TypeAliasMap[alias].push_back(type);
						foundValidContainerReference = true;
					}
				}

				if (!foundValidContainerReference)
				{
					const std::string typeWithFullNamespace = aliasNamespace + alias;

					if (auto iter = TypeAliasMap.find(alias);
						iter != TypeAliasMap.end())
					{
						if (std::find(iter->second.begin(), iter->second.end(), typeWithFullNamespace) == iter->second.end())
						{
							TypeAliasMap[alias].push_back(typeWithFullNamespace);
							Log_Warn("FilePath: '%s' Found duplicate 'using' alias: '%s', type '%s'.\n", fileData.FullPath.c_str(), alias.c_str(), type.c_str());
						}
					}
					else
					{
						TypeAliasMap[alias].push_back(typeWithFullNamespace);
					}

					std::string currentAliasAndNamespace;
					for (int i = static_cast<int>(aliasNamespaceSplit.size()) - 1; i >= 0; i--)
					{
						currentAliasAndNamespace.insert(0, aliasNamespaceSplit[i] + "::");
						TypeAliasMap[currentAliasAndNamespace + alias].push_back(aliasNamespace + alias);
						TypeAliasMap["::" + currentAliasAndNamespace + alias].push_back(aliasNamespace + alias);
					}
				}
			}
		}

		fileData.Parsed = true;
	}

	uint64_t FileParser::FindNextContainer(FileParsedData& fileData) const
	{
		// Check if we can reflect this class/struct. 
		// Note: This will catch 'enum class' but as that will not compile it should exist when building so something I'm not worried about at the moment.
		const uint64_t classIdx = static_cast<size_t>(fileData.Data.find(Keys::ClassKey, fileData.Cursor));
		const uint64_t structIdx = static_cast<size_t>(fileData.Data.find(Keys::StructKey, fileData.Cursor));
		if (classIdx == std::string::npos
			&& structIdx == std::string::npos)
		{
			// Can't reflect this class/struct. Return.
			return -1;
		}

		const uint64_t containerStartIdx = std::min(classIdx, structIdx);

		Parser::ReflectContainerData* containerData;

		if (!fileData.ReflectData.empty() && !fileData.ReflectData.back().HasBeenParsed)
		{
			containerData = &fileData.ReflectData.back();
		}
		else
		{
			containerData = &fileData.ReflectData.emplace_back(ReflectContainerData());
		}

		if (classIdx < structIdx)
		{
			containerData->ReflectType = EReflectType::Class;
		}
		else
		{
			containerData->ReflectType = EReflectType::Struct;
		}

		return containerStartIdx;
	}

	uint64_t FileParser::FindNextReflectContainer(FileParsedData& fileData, EReflectType* reflectType) const
	{
		// Check if we can reflect this class/struct. 
		const uint64_t reflectClassIdx = static_cast<size_t>(fileData.Data.find(Keys::RefectClassKey, fileData.Cursor));
		const uint64_t reflectStructIdx = static_cast<size_t>(fileData.Data.find(Keys::RefectStructKey, fileData.Cursor));
		if (reflectClassIdx == std::string::npos
			&& reflectStructIdx == std::string::npos)
		{
			// Can't reflect this class/struct. Return.
			return -1;
		}

		uint64_t relfectCurosrIdx = std::min(reflectClassIdx, reflectStructIdx);
		if (IsCursorWithinComment(fileData, relfectCurosrIdx, true))
		{
			return -1;
		}

		if (reflectType != nullptr)
		{
			*reflectType = reflectClassIdx < reflectStructIdx ? EReflectType::Class : EReflectType::Struct;
		}

		return relfectCurosrIdx;
	}

	bool FileParser::ParseContainerReflectProperties(FileParsedData& fileData) const
	{
		Parser::ReflectContainerData& containerData = fileData.ReflectData.back();

		const char* reflectContainerKey = containerData.ReflectType == EReflectType::Class ? Keys::RefectClassKey : Keys::RefectStructKey;
		if (fileData.Data.find(reflectContainerKey, fileData.Cursor) != fileData.Cursor)
		{
			Log_Error("[FileParser::ParseContainerReflectProperties] Cursor is expected to be at a REFLECT_[CLASS/STRUCT] macro. This is not the case. File:");
			Log_Error("'%s' will not be completely reflected.\n", fileData.FileName);
			return false;
		}

		fileData.Cursor = fileData.Cursor + strlen(reflectContainerKey);
		// Get the flags passed though the REFLECT macro.
		containerData.ContainerProps = ReflectFlags(fileData);

		return true;
	}

	bool FileParser::ParseContainerHeader(FileParsedData& fileData) const
	{
		Parser::ReflectContainerData& containerData = fileData.ReflectData.back();

		const uint64_t classIdx = static_cast<size_t>(fileData.Data.find(Keys::ClassKey, fileData.Cursor));
		const uint64_t structIdx = static_cast<size_t>(fileData.Data.find(Keys::StructKey, fileData.Cursor));

		const char* containerKey = containerData.ReflectType == EReflectType::Class ? Keys::ClassKey : Keys::StructKey;
		const uint64_t containerStartIdx = fileData.Data.find(containerKey, fileData.Cursor);

		if (containerStartIdx == std::string::npos)
		{
			Log_Error("[FileParser::ParseContainerHeader] Expected to find '%d'. This is not the case. File:", containerKey);
			Log_Error("'%s' will not be completely reflected.\n", fileData.FileName);
			return false;
		}

		fileData.Cursor = containerStartIdx;
		if (IsCursorWithinComment(fileData, fileData.Cursor, true))
		{
			return false;
		}

		fileData.Cursor = containerStartIdx + strlen(containerKey);

		containerData.Namespaces = FindAllNamespaces(fileData, fileData.Cursor);
		containerData.IfDefines = FindAllIfDefines(fileData, fileData.Cursor);

		// Found out if this class/struct is templated.
		if (uint64_t tempalteIdx = CheckForTemplate(fileData); 
			tempalteIdx != -1)
		{
			if (IsCursorWithinComment(fileData, tempalteIdx, true))
			{
				return false;
			}

			const uint64_t templateStartIdx = fileData.Data.rfind("<", fileData.Cursor);
			const uint64_t templateEndIdx = FindEndOfTemplate(fileData, templateStartIdx);
			if (fileData.Cursor < templateEndIdx)
			{
				// We have found a 'class/struct' string within a template definition.
				fileData.Cursor = templateEndIdx;
				return false;
			}
			containerData.TemplateTypes = ParseTemplateData(fileData);
		}

		std::string containerName;
		char breakChars[] =
		{
			':', '{', '\n', ';'
		};

		// Find the containers name
		while (std::find(std::begin(breakChars), std::end(breakChars), fileData.Data.at(fileData.Cursor)) == std::end(breakChars))
		{
			if (fileData.Data.at(fileData.Cursor) != ' ')
			{
				containerName += fileData.Data.at(fileData.Cursor);
			}
			++fileData.Cursor;
		}


		if (fileData.Data[fileData.Cursor] == ';')
		{
			// Forward delectations are not supported at the moment.
			return false;
		}

		for (const std::string str : m_ignoreStrings)
		{
			Util::RemoveString(containerName, str);
		}

		containerData.Name = containerName;
		containerData.PrettyName = PrettyString(containerName);
		containerData.Type = containerName;
		containerData.TypeSize = DEFAULT_TYPE_SIZE;

		// We are inheriting things.
		const uint64_t inheritanceIdx = fileData.Data.find(':', fileData.Cursor);
		const uint64_t containerStatIdx = fileData.Data.find('{', fileData.Cursor);
		const bool hasInheritance = inheritanceIdx != std::string::npos
			&& containerStatIdx != std::string::npos
			&& inheritanceIdx < containerStatIdx;

		if (hasInheritance)
		{
			FindNextChar(fileData, ':');
			++fileData.Cursor;
			std::string type;
			while (fileData.Data.at(fileData.Cursor) != '{')
			{
				if (fileData.Data.at(fileData.Cursor) == ',')
				{
					Util::RemoveCharAll(type, ' ');
					Util::RemoveString(type, Keys::PublicKey);
					Util::RemoveString(type, Keys::ProtectedKey);
					Util::RemoveString(type, Keys::PrivateKey);
					containerData.Inheritance.push_back({ type, type });
					type.clear();
				}
				else
				{
					type += fileData.Data.at(fileData.Cursor);
				}
				++fileData.Cursor;
			}
			Util::RemoveCharAll(type, ' ');
			Util::RemoveCharAll(type, '\n');
			Util::RemoveCharAll(type, '\t');
			Util::RemoveCharAll(type, '\r');
			Util::RemoveString(type, Keys::PublicKey);
			Util::RemoveString(type, Keys::ProtectedKey);
			Util::RemoveString(type, Keys::PrivateKey);

			std::string typeWithNamespace = type;

			while (type.find("::") != std::string::npos)
			{
				uint64_t index = type.find("::");
				type = type.substr(index + 2);
			}
			containerData.Inheritance.push_back({ type, typeWithNamespace });
		}

		if (!containerData.Namespaces.empty())
		{
			for (const std::string& str : containerData.Namespaces)
			{
				containerData.NameWithNamespace += str + "::";
			}
		}
		containerData.NameWithNamespace += containerData.Name;

		return true;
	}

	void FileParser::ReflectContainer(FileParsedData& fileData) const
	{
		REFLECT_PROFILE_FUNCTION();

		if (fileData.ReflectData.empty())
		{
			return;
		}

		size_t endOfContainerCursor = FindEndOfConatiner(fileData);

		// Good, we have a reflected container class/struct.
		// First find out which it is and verify that we are inheriting from "ReflectObject".
		std::stack<char> bracketStack;
		Parser::ReflectContainerData& conatinerData = fileData.ReflectData.back();

		size_t generatedBodyLine = fileData.Data.find(Keys::ReflectGeneratedBodykey, fileData.GeneratedBodyLineOffset);
		if (generatedBodyLine != std::string::npos)
		{
			//assert(generatedBodyLine != -1 && );
			fileData.GeneratedBodyLineOffset = generatedBodyLine + strlen(Keys::ReflectGeneratedBodykey);
			conatinerData.ReflectGenerateBodyLine = CountNumberOfSinceTop(fileData, generatedBodyLine, '\n') + 1ull;
		}
		else
		{
			generatedBodyLine = 0;
			if (std::find(conatinerData.ContainerProps.begin(), conatinerData.ContainerProps.end(), REFLECT_LOOKUP_ONLY) == conatinerData.ContainerProps.end())
			{
				Log_Warn("[FileParser::ReflectContainer] 'REFLECT_GENERATED_BODY()' is missing from a'%s'.\n", fileData.FileName);
			}
		}

		// Set us to the start of the class/struct. We should continue until we find something.
		char c = FindNextChar(fileData, '{');
		std::vector<std::string> reflectFlags;
		while (true)
		{
			std::vector<PropertyMeta> reflectPropertyMetas;

			if (CheckForEndOfFile(fileData, endOfContainerCursor))
				break;

			if (m_options->options.at(Keys::Reflect_CMD_Option_Reflect_Full_EXT) == "true")
			{
				c = FindNextChar(fileData, emptyChars);
				std::string word = FindNextWord(fileData, generalEndChars);

				if (CheckForTypeAlias(word))
				{
					FindNextChar(fileData, ';');
					continue;
				}

				// Check for child strcuts/class

				if (CheckForVisibility(word))
				{
					++fileData.Cursor;
					continue;
				}

				// Check for constructor/destructor
				if (CheckForConstructor(fileData, conatinerData, word))
					continue;

				if (CheckForIgnoreWord(fileData, word))
					continue;

				if (CheckForOperatorFunction(fileData, word))
					continue;

				if (CheckForComments(fileData, word))
					continue;

				if (CheckForFriends(fileData, word))
					continue;

				// We should now have a type (unless there are macros or compiler keywords).
				if (IsWordReflectKey(word))
				{
					if (word == Keys::ReflectGeneratedBodykey)
					{
						c = FindNextChar(fileData, { '(', ')' });
						continue;
					}
					else if (word == Keys::ReflectPropertyKey)
					{
						// Get the flags for the property
						reflectPropertyMetas = ReflectPropertyMetas(fileData);
						reflectFlags = ReflectFlags(fileData);
						continue;
					}
				}
				else
				{
					// We think we have function or memeber.
					fileData.Cursor -= (size_t)word.size();
				}

				if (CheckForEndOfFile(fileData, endOfContainerCursor))
					break;

				EReflectType refectType = CheckForReflectType(fileData);
				if (refectType == EReflectType::Member)
				{
					conatinerData.Members.push_back(GetMember(fileData, reflectFlags));
					conatinerData.Members.back().PropertyMetas = reflectPropertyMetas;
				}
				else if (refectType == EReflectType::Function)
				{
					if (!CheckForConstructor(fileData, conatinerData, word))
					{
						Parser::ReflectFunctionData funcData = GetFunction(fileData, reflectFlags);
						if (!funcData.Name.empty())
						{
							conatinerData.Functions.push_back(funcData);
							conatinerData.Functions.back().PropertyMetas = reflectPropertyMetas;
						}
					}
				}
				//else
				//{
				//	assert(false);
				//	continue;
				//}
			}
			else
			{
				if (CheckForEndOfFile(fileData, endOfContainerCursor))
					break;

				size_t newCursor = (size_t)fileData.Data.find(Keys::ReflectPropertyKey, fileData.Cursor);
				if (newCursor > endOfContainerCursor)
				{
					fileData.Cursor = endOfContainerCursor;
					break;
				}
				fileData.Cursor = newCursor;

				if (fileData.Cursor == std::string::npos)
				{
					fileData.Cursor = endOfContainerCursor;
					continue;
				}

				// Get any '#if'/'#ifdef'/'#if defined(' before the REFLECT_PROPERTY macro.
				std::vector<std::string> ifDefinesBeforeReflectProperty = FindAllIfDefines(fileData, fileData.Cursor);

				fileData.Cursor += (size_t)strlen(Keys::ReflectPropertyKey);
				reflectPropertyMetas = ReflectPropertyMetas(fileData);
				if (fileData.AbortParsing)
				{
					return;
				}
				reflectFlags = ReflectFlags(fileData);
				if (fileData.AbortParsing)
				{
					return;
				}
				//FindNextChar(fileData, generalEndChars);
				MoveToEndOfScope(fileData, '(', ')');
				if (fileData.AbortParsing)
				{
					return;
				}

				// Check if 'REFLECT_PROPERTY' macro ends with a semi-colon.
				while (fileData.Cursor < fileData.Data.size())
					{
						const char c = fileData.Data[fileData.Cursor];
						if (c == ';')
						{
							++fileData.Cursor;
							break;
						}
						else if (std::find(emptyChars.begin(), emptyChars.end(), c) == emptyChars.end())
						{
							break;
						}

						if (CheckForEndOfFile(fileData, endOfContainerCursor))
						{
							assert(false);
							break;
						}
						else
						{
							++fileData.Cursor;
						}
					}


				EReflectType refectType = CheckForReflectType(fileData);
				ReflectTypeNameData* property = nullptr;

				if (refectType == EReflectType::Member)
				{
					conatinerData.Members.push_back(GetMember(fileData, reflectFlags));
					conatinerData.Members.back().PropertyMetas = reflectPropertyMetas;
					property = &conatinerData.Members.back();
				}
				else if (refectType == EReflectType::Function)
				{
					conatinerData.Functions.push_back(GetFunction(fileData, reflectFlags));
					conatinerData.Functions.back().PropertyMetas = reflectPropertyMetas;
					property = &conatinerData.Functions.back();
				}

				std::vector<std::string> ifDefinesAfterReflectProperty = FindAllIfDefines(fileData, fileData.Cursor);

				if (!ifDefinesBeforeReflectProperty.empty() && !ifDefinesAfterReflectProperty.empty())
				{
					Log_Error("[FileParser::ReflectContainer] There is a mismatch between a '#if', '#ifdef', '#if defined' between a REFLECT_PROPERTY");
					Log_Error("and either a member or function it is associated with, File: '%s', Property: '%s'.\n", fileData.FullPath.c_str(), property->Name.c_str());

					// TODO: Instead of clearing the defines (so nothing should compile until fixed). Maybe defines should be stored as where in the file
					// they are allowing for filtering here. We could store the cursor position of the define and filter them via that.
					ifDefinesBeforeReflectProperty.clear();
					ifDefinesAfterReflectProperty.clear();
				}
				/*
				* TODO: Not sure if this should be allowed:
				* `REFLECT_PROPERTY(EditorVisible, Meta(ClampMin(0.0), ClampMax(1.0)))
				* `#if SOME_DEFINE
				* `float someFloat = 0.0f;
				* `#endif
				* As it feels more like we are trying to reflect something that might no exist. For the time being allow it.
				* But something to think about.
				*/

				if (refectType == EReflectType::Member)
				{
					std::move(ifDefinesBeforeReflectProperty.begin(), ifDefinesBeforeReflectProperty.end(), std::back_inserter(conatinerData.Members.back().IfDefines));
					std::move(ifDefinesAfterReflectProperty.begin(), ifDefinesAfterReflectProperty.end(), std::back_inserter(conatinerData.Members.back().IfDefines));
				}
				else if (refectType == EReflectType::Function)
				{
					std::move(ifDefinesBeforeReflectProperty.begin(), ifDefinesBeforeReflectProperty.end(), std::back_inserter(conatinerData.Functions.back().IfDefines));
					std::move(ifDefinesAfterReflectProperty.begin(), ifDefinesAfterReflectProperty.end(), std::back_inserter(conatinerData.Functions.back().IfDefines));
				}
			}

			reflectFlags = {};
		}
	}

	void FileParser::GetAllCPPIncludes(FileParsedData& fileData) const
	{
		REFLECT_PROFILE_FUNCTION();

		size_t index = fileData.Data.find(Keys::ReflectCPPIncludeKey);
		while (index != std::string::npos)
		{
			std::string line = fileData.Data.substr(index, fileData.Data.find(';', index) - index);
			line = line.substr(line.find('(') + 2, line.find(')') - (line.find('(') + 3));
			fileData.CPPIncludes.push_back(line);
			index = fileData.Data.find(Keys::ReflectCPPIncludeKey, fileData.Data.find(';', index));
		}
	}

	std::vector<std::string> FileParser::FindAllNamespaces(FileParsedData fileData, size_t reflectStart) const
	{
		fileData.Cursor = reflectStart;
		std::vector<std::string> namespaces;
		size_t closeBracketCount = 0;

		while (fileData.Cursor != 0)
		{
			if (fileData.Data[fileData.Cursor] == '}')
			{
				++closeBracketCount;
			}
			else if (fileData.Data[fileData.Cursor] == '{')
			{
				if (closeBracketCount == 0)
				{
					--fileData.Cursor;
					std::string namespaceName = FindPreviousNamespace(fileData);
					if (!namespaceName.empty())
					{
						namespaces.push_back(namespaceName);
					}
				}
				else
				{
					--closeBracketCount;
				}
			}
			--fileData.Cursor;
		}
	
		if (!namespaces.empty())
		{
			std::reverse(namespaces.begin(), namespaces.end());
		}

		return namespaces;
	}

	std::string FileParser::FindPreviousNamespace(FileParsedData& fileData) const
	{
		FindNextChar(fileData, emptyChars, true);
		std::string namespaceName = FindNextWord(fileData, emptyChars, true);

		FindNextChar(fileData, emptyChars, true);
		std::string namespaceAlias = FindNextWord(fileData, emptyChars, true);

		if (namespaceAlias == Keys::Namespace)
		{
			return namespaceName;
		}
		return "";
	}

	std::vector<std::string> FileParser::FindAllIfDefines(FileParsedData fileData, size_t reflectStart) const
	{
		fileData.Cursor = 0;
		std::stack<std::string> ifDefines;

		while (fileData.Cursor < reflectStart)
		{
			const uint64_t endIfIndex = fileData.Data.find("#endif", fileData.Cursor);
			const uint64_t elseIfIndex = fileData.Data.find("#elif", fileData.Cursor);
			const uint64_t elseIndex = fileData.Data.find("#else", fileData.Cursor);
			const uint64_t firstEndIdx = std::min(endIfIndex, std::min(elseIfIndex, elseIndex));

			const uint64_t ifDefIndex = fileData.Data.find("#ifdef", fileData.Cursor);
			const uint64_t ifIndex = fileData.Data.find("#if", fileData.Cursor);
			const uint64_t definedIndex = fileData.Data.find("defined(", fileData.Cursor);
			uint64_t firstIndex = std::min(ifIndex, std::min(ifDefIndex, definedIndex));

			const bool ifDefExists = firstIndex != std::string::npos;
			const bool endDefExists = firstEndIdx != std::string::npos;

			bool isIfDef = ifDefIndex < definedIndex;

			//if ((endIfIndex < reflectStart
			//	&& endIfIndex < firstIndex)
			//	|| (elseIfIndex < reflectStart
			//		&& elseIfIndex < firstIndex)
			//	|| (elseIndex < reflectStart
			//		&& elseIndex < firstIndex))
			if (endDefExists && (firstEndIdx < reflectStart && firstEndIdx < firstIndex))
			{
				if (!ifDefines.empty())
				{
					ifDefines.pop();
				}
				fileData.Cursor = firstEndIdx;
				FindNextChar(fileData, '\n');
				continue;
			}

			if (firstIndex > reflectStart)
			{
				// The #ifdef/#if defined is beyond our container.
				break;
			}

			if (!ifDefExists && !endDefExists)
			{
				// There is no define or end of a define here. Just exit.
				break;
			}

			// Check to see if we are evaluating a '#if', '#ifdef', '#if defined(' which is within a comment line/block.
			// If so then ignore.
			if (IsCursorWithinComment(fileData, firstIndex, true))
			{
				fileData.Cursor = firstIndex;
				break;
			}

			fileData.Cursor = firstIndex;

			FindNextChar(fileData, '\n');
			std::string define = fileData.Data.substr(firstIndex, fileData.Cursor - firstIndex);
			if (ifIndex < definedIndex && ifIndex < ifDefIndex)
			{
			}
			else if (definedIndex < ifDefIndex)
			{
				define = "#if " + define;
			}
			ifDefines.push(define);
		}

		std::vector<std::string> result;
		while (!ifDefines.empty())
		{
			result.push_back(ifDefines.top());
			ifDefines.pop();
		}

		return result;
	}

	size_t FileParser::FindEndOfConatiner(const FileParsedData& fileData) const
	{
		REFLECT_PROFILE_FUNCTION();

		size_t cursor = fileData.Cursor;
		char lastCharacter = '\0';
		char c = fileData.Data[cursor];
		bool foundStartOfContainer = false;
		std::stack<char> symbols;
		while (true)
		{
#ifdef EXP_PARSER
			if (!foundStartOfContainer)
			{
				if (c == '{')
				{
					symbols.push(c);
					foundStartOfContainer = true;
				}
			}
			else
			{
				if (c == '{')
				{
					symbols.push(c);
				}
				else if (c == '}')
				{
					symbols.pop();
				}

				if (symbols.size() == 0)
				{
					char nextChar = FindNextChar(fileData, cursor, emptyChars);
					if (nextChar != ';')
					{
						Log_Warn("[FileParser::FindEndOfConatiner] Did not find ';' at end of the container: '%s'.\n", fileData.ReflectData.back().NameWithNamespace.c_str());
					}
					break;
				}
			}
#else
			if (lastCharacter == '}' && c == ';')
			{
				break;
			}

			if (c != '\t' && c != '\n')
			{
				lastCharacter = c;
			}
#endif
			++cursor;
			c = fileData.Data[cursor];
		}
		return cursor;
	}

	std::vector<std::string> FileParser::ReflectFlags(FileParsedData fileData) const
	{
		REFLECT_PROFILE_FUNCTION();

		// Get the flags passed though the REFLECT macro.
		std::string flag;
		std::vector<std::string> flags;

		assert(fileData.Data[fileData.Cursor] == '(');
		++fileData.Cursor;

		size_t scope = 1;
		bool discardFlag = false;

		while (scope > 0)
		{
			if (fileData.Cursor == fileData.Data.size())
			{
				Log_Error("[FileParser::ReflectFlags] File cursor reached the end of the file '%s'. This should not happen.", fileData.FileName.data());
				Log_Error("Please check that all 'REFLECT_PROPERTY' is correct.\n"); 
				fileData.AbortParsing = true;
				return { };
			}

			char c = fileData.Data[fileData.Cursor];
			if (c == '(')
			{
				++scope;
				discardFlag = true;
			}
			else if (c == ')')
			{
				--scope;
				if (scope == 1)
				{
					discardFlag = false;
					flag = "";
				}
			}
			else if (c == ',')
			{
				if (!discardFlag && !flag.empty())
				{
					flags.push_back(flag);
				}
				flag = "";
			}
			else if (!discardFlag)
			{
				if (c != ' ' && c != '\t')
				{
					flag += c;
				}
			}
			++fileData.Cursor;
		}
		++fileData.Cursor;
		if (!flag.empty())
		{
			Util::RemoveCharAll(flag, '"');
			flags.push_back(flag);
		}

		return flags;
	}

	std::vector<PropertyMeta> FileParser::ReflectPropertyMetas(FileParsedData fileData) const
	{
		REFLECT_PROFILE_FUNCTION();

		std::string key;
		std::string value;
		std::vector<PropertyMeta> propertyMetas;

		std::string scopeString;
		{
			size_t scope = 1;
			assert(fileData.Data[fileData.Cursor] == '(');
			++fileData.Cursor;

			while (scope > 0)
			{
				if (fileData.Cursor == fileData.Data.size())
				{
					Log_Error("[FileParser::ReflectPropertyMetas] Mismatch brackets for property in file '%s'. Returning no property meta data.\n", fileData.FileName.data());
					fileData.AbortParsing = true;
					return { };
				}

				char c = fileData.Data[fileData.Cursor];
				if (c == '(')
				{
					++scope;
					if (scope > 1)
					{
						scopeString += c;
					}
				}
				else if (c == ')')
				{
					if (scope > 1)
					{
						scopeString += c;
					}
					--scope;
				}
				else
				{
					scopeString += c;
				}
				++fileData.Cursor;
			}
		}

		Util::RemoveCharAll(scopeString, ' ');

		if (const size_t metaIdx = scopeString.find(Keys::MetaPropertyKey); 
			metaIdx != std::string::npos)
		{
			size_t idx = metaIdx;
			idx += strlen(Keys::MetaPropertyKey);

			assert(scopeString[idx] == '(');
			++idx;
			size_t metaScope = 1;
			std::string metaScopeString;

			while (metaScope > 0)
			{
				char c = scopeString[idx];
				if (c == '(')
				{
					++metaScope;
					if (metaScope > 1)
					{
						metaScopeString += c;
					}
				}
				else if (c == ')')
				{
					if (metaScope > 1)
					{
						metaScopeString += c;
					}
					--metaScope;
				}
				else
				{
					metaScopeString += c;
				}
				++idx;
			}

			Util::RemoveCharAll(metaScopeString, ' ');

			std::vector<std::string> metas = Util::SplitString(metaScopeString, ',');

			for (size_t metaIdx = 0; metaIdx < metas.size(); ++metaIdx)
			{
				const std::string& meta = metas[metaIdx];
				const size_t openBracket = meta.find('(');
				const size_t closeBracket = meta.find(')');
				assert(openBracket != std::string::npos && closeBracket != std::string::npos);

				std::string key = meta.substr(0, openBracket);
				std::string value = meta.substr(openBracket + 1, (closeBracket - openBracket) - 1);
				PropertyMeta newPropertyMeta(key.c_str(), value.c_str());
				propertyMetas.push_back(std::move(newPropertyMeta));
			}
		}

		return propertyMetas;
	}

	void FileParser::ResolveNamespaces()
	{
		REFLECT_PROFILE_FUNCTION();
		Log_Info("Resolving namespaces.\n");


		for (auto& file : m_filesParsed)
		{
			for (auto& reflectedData : file.ReflectData)
			{
				for (auto& member : reflectedData.Members)
				{
					if (member.IsTemplate)
					{
						Parser::ReflectContainerData* templateFirst = FindReflectContainerData(member.TemplateFirstType);
						Parser::ReflectContainerData* templateSecond = FindReflectContainerData(member.TemplateSecondType);

						if (templateFirst)
						{
							member.TemplateFirstType = templateFirst->NameWithNamespace;
						}
						if (templateSecond)
						{
							member.TemplateSecondType = templateSecond->NameWithNamespace;
						}
					}
					else
					{
						Parser::ReflectContainerData* memberInheritanceContainerData = FindReflectContainerData(member.Type);
						if (memberInheritanceContainerData)
						{
							member.NameWithNamespace = memberInheritanceContainerData->NameWithNamespace;
						}
						else
						{
							std::string aliasName = FindFullAliasName(member.Type);
							if (!aliasName.empty())
							{
								member.NameWithNamespace = aliasName;
							}
						}
					}
				}
			}
		}
	}

	void FileParser::LinkAllInheritances()
	{
		REFLECT_PROFILE_FUNCTION();
		Log_Info("Linking all inheritances.\n");

		std::function<void(ReflectInheritanceData&, Log::ProgressBar&, uint32_t&)> linkInheritanceFunc =
			[&linkInheritanceFunc, this](ReflectInheritanceData& inheritanceData, Log::ProgressBar& progressBar, uint32_t& progressBarCount)
			{
				progressBar.SetProgress(++progressBarCount);

				Parser::ReflectContainerData* inheritanceContainerData = FindReflectContainerData(inheritanceData.NameWithNamespace);
				if (!inheritanceContainerData)
				{
					return;
				}

				for (auto& typeInheritance : inheritanceContainerData->Inheritance)
				{
					if (typeInheritance.NameWithNamespace != "REFLECT_BASE")
					{
						inheritanceData.Inheritances.push_back(typeInheritance);
						linkInheritanceFunc(inheritanceData.Inheritances.back(), progressBar, progressBarCount);
					}
				}
			};

#if FILE_PARSER_MULTITHREADED
		std::vector<std::thread> threads;
#endif
		// With the progress bar we do end up searching for inheritances twice (which is not great).
		// TODO store the number of inheritances in a chain for a container.
		Log::ProgressBar linkInheritanceProgressBar(GetTotalInheritancesToLink(), "Inheritances Linked", Log::ProgressBar::Options::All);
		uint32_t progressCount = 0;
		linkInheritanceProgressBar.SetProgress(progressCount);

		for (auto& file : m_filesParsed)
		{
			for (auto& reflectedData : file.ReflectData)
			{
#if FILE_PARSER_MULTITHREADED
				std::thread thread = std::thread([&]()
				{
#endif
					if (reflectedData.NameWithNamespace == "Insight::Graphics::TextureDrawData_DX12")
					{
						int asd = 0;
					}

					REFLECT_PROFILE_SCOPE_CSTR(reflectedData.NameWithNamespace.c_str());
					// Go through all our struct/class inheritance
					for (auto& inheritanceItem : reflectedData.Inheritance)
					{
						//REFLECT_PROFILE_SCOPE_CSTR(inheritanceItem.Name.c_str());
						linkInheritanceProgressBar.SetPostText("Inheritance Class '" + inheritanceItem.NameWithNamespace + "'");

						// This is not great. Currently the solution is to try and find a reflected container with the same name 
						// regardless of the namespace. So if you have two classes named the same in different namespaces this won't work.
						if (Parser::ReflectContainerData* inheritanceData = FindReflectContainerData(inheritanceItem.NameWithNamespace);
							inheritanceData != nullptr)
						{
							inheritanceItem.IsParsed = true;
							inheritanceItem.NameWithNamespace = inheritanceData->NameWithNamespace;
							inheritanceItem.HasCodeGenerated = inheritanceData->GenerateReflectCode;
						}
						else
						{
							inheritanceItem.IsParsed = false;
							inheritanceItem.HasCodeGenerated = false;
						}

						linkInheritanceFunc(inheritanceItem, linkInheritanceProgressBar, progressCount);
					}

					for (auto& member : reflectedData.Members)
					{
						// Clear the inheritance chain as we are redoing it.
						member.TypeInheritance.clear();
						linkInheritanceProgressBar.SetPostText("Inheritance Class '" + member.Name + "'");

						Parser::ReflectContainerData* memberInheritanceContainerData = FindReflectContainerData(member.Type);
						if (!memberInheritanceContainerData)
						{
							continue;
						}

						for (auto& typeInheritance : memberInheritanceContainerData->Inheritance)
						{
							if (typeInheritance.Name != "REFLECT_BASE")
							{
								member.TypeInheritance.push_back(typeInheritance);
								linkInheritanceFunc(member.TypeInheritance.back(), linkInheritanceProgressBar, progressCount);
							}
						}
					}

#if FILE_PARSER_MULTITHREADED
				});
				threads.push_back(std::move(thread));
#endif
			}
		}

#if FILE_PARSER_MULTITHREADED
		for (size_t i = 0; i < threads.size(); i++)
		{
			threads[i].join();
		}
#endif
	}

	uint64_t FileParser::GetTotalInheritancesToLink() const
	{
		REFLECT_PROFILE_FUNCTION();

		std::function<void(const ReflectInheritanceData&, uint64_t&)> getInheritanceLinkCountFunc =
			[&getInheritanceLinkCountFunc, this](const ReflectInheritanceData& inheritanceData, uint64_t& totalInheritancesToLink)
			{
				++totalInheritancesToLink;
				const Parser::ReflectContainerData* inheritanceContainerData = FindReflectContainerData(inheritanceData.NameWithNamespace);
				if (!inheritanceContainerData)
				{
					return;
				}

				for (auto& typeInheritance : inheritanceContainerData->Inheritance)
				{
					if (typeInheritance.NameWithNamespace != "REFLECT_BASE")
					{
						getInheritanceLinkCountFunc(typeInheritance, totalInheritancesToLink);
					}
				}
			};

		uint64_t inherentiacesTolink = 0;
		for (auto& file : m_filesParsed)
		{
			for (auto& reflectedData : file.ReflectData)
			{
				for (auto& inheritanceItem : reflectedData.Inheritance)
				{
					getInheritanceLinkCountFunc(inheritanceItem, inherentiacesTolink);
				}

				for (auto& member : reflectedData.Members)
				{
					// Clear the inheritance chain as we are redoing it.
					//member.TypeInheritance.clear();

					const Parser::ReflectContainerData* memberInheritanceContainerData = FindReflectContainerData(member.Type);
					if (!memberInheritanceContainerData)
					{
						continue;
					}

					for (auto& typeInheritance : memberInheritanceContainerData->Inheritance)
					{
						if (typeInheritance.Name != "REFLECT_BASE")
						{
							getInheritanceLinkCountFunc(typeInheritance, inherentiacesTolink);
						}
					}
				}
			}
		}

		return inherentiacesTolink;
	}

	void FileParser::RemoveLookupOnlyContainers()
	{
		REFLECT_PROFILE_FUNCTION();
		Log_Info("Removing lookup only containers.\n");

		Log::ProgressBar progrssBar(m_toalNumberOfContainersParsed, "Containers Checked For Removal", Log::ProgressBar::All);
		uint32_t progrssCount = 0;
		progrssBar.SetProgress(progrssCount);

		for (size_t parsedDataIdx = 0; parsedDataIdx < m_filesParsed.size(); ++parsedDataIdx)
		{
			FileParsedData& parsedData = m_filesParsed[parsedDataIdx];
			std::vector<const ReflectContainerData*> reflectDataToBeRemoved;
			
			for (int refecltDataIdx = static_cast<int>(parsedData.ReflectData.size()) - 1; refecltDataIdx >= 0; --refecltDataIdx)
			{
				progrssBar.SetProgress(++progrssCount);

				const ReflectContainerData& reflectData = parsedData.ReflectData[refecltDataIdx];
				if (auto iter = std::find(reflectData.ContainerProps.begin(), reflectData.ContainerProps.end(), REFLECT_LOOKUP_ONLY);
					iter != reflectData.ContainerProps.end())
				{
					reflectDataToBeRemoved.push_back(&reflectData);
				}
				else if (!reflectData.GenerateReflectCode)
				{
					reflectDataToBeRemoved.push_back(&reflectData);
				}
				else
				{
					++m_toalNumberOfContainersToGenerateCode;
				}
			}

			for (size_t refecltDataToRemoveIdx = 0; refecltDataToRemoveIdx < reflectDataToBeRemoved.size(); ++refecltDataToRemoveIdx)
			{
				const ReflectContainerData* removeData = reflectDataToBeRemoved[refecltDataToRemoveIdx];
				auto removeIter = std::remove_if(parsedData.ReflectData.begin(), parsedData.ReflectData.end(), [&removeData](const ReflectContainerData& reflectData)
					{
						return removeData == &reflectData;
					});
				if (removeIter != parsedData.ReflectData.end())
				{
					parsedData.ReflectData.erase(removeIter);
				}
			}
		}
	}

	char FileParser::FindNextChar(FileParsedData const& fileData, size_t& cursor, const std::vector<char>& ignoreChars, bool reverse) const
	{
		REFLECT_PROFILE_FUNCTION();

		FileParsedData copyFileData = fileData;
		copyFileData.Cursor = cursor;
		char c = FindNextChar(copyFileData, ignoreChars, reverse);
		cursor = copyFileData.Cursor;
		return c;
	}

	char FileParser::FindNextChar(FileParsedData& fileData, char charToFind, bool reverse) const
	{
		REFLECT_PROFILE_FUNCTION();

		char c = fileData.Data[fileData.Cursor];
		while (c != charToFind)
		{
			if (reverse ? --fileData.Cursor : ++fileData.Cursor < fileData.Data.size())
				c = fileData.Data[fileData.Cursor];
			else
				break;
		}
		return c;
	}

	char FileParser::FindNextChar(FileParsedData& fileData, const std::vector<char>& ignoreChars, bool reverse) const
	{
		REFLECT_PROFILE_FUNCTION();

		reverse ? --fileData.Cursor : ++fileData.Cursor;
		while (std::find(ignoreChars.begin(), ignoreChars.end(), fileData.Data[fileData.Cursor]) != ignoreChars.end())
		{
			reverse ? --fileData.Cursor : ++fileData.Cursor;
		}
		return fileData.Data[fileData.Cursor];
	}

	std::string FileParser::FindNextWord(FileParsedData& fileData, const std::vector<char>& endChars, bool reverse) const
	{
		REFLECT_PROFILE_FUNCTION();

		std::string s;
		s += fileData.Data[fileData.Cursor];
		char c = FindNextChar(fileData, std::vector<char>(), reverse);
		while (std::find(endChars.begin(), endChars.end(), c) == endChars.end())
		{
			s += c;
			c = FindNextChar(fileData, std::vector<char>(), reverse);
		}

		if (reverse)
		{
			std::reverse(s.begin(), s.end());
		}

		return s;
	}

	std::string FileParser::FindNextWord(const FileParsedData& fileData, size_t& cursor, const std::vector<char>& endChars, bool reverse) const
	{
		FileParsedData copyFileData = fileData;
		copyFileData.Cursor = cursor;
		return FindNextWord(copyFileData, endChars, reverse);
	}

	bool FileParser::IsWordReflectKey(std::string_view view) const
	{
		REFLECT_PROFILE_FUNCTION();
		return view == Keys::ReflectGeneratedBodykey 
			|| view == Keys::ReflectPropertyKey;
	}

	std::string_view FileParser::GetCurrentLineFromCurosr(const FileParsedData& fileData, const uint64_t cursor) const
	{
		const uint64_t previousNewLineIdx = fileData.Data.rfind("\n", cursor);
		const uint64_t nextNewLineIdx = fileData.Data.find("\n", cursor);

		const uint64_t newLineStartIdx = previousNewLineIdx != std::string::npos ? previousNewLineIdx : 0;
		const uint64_t newLineEndIdx = nextNewLineIdx != std::string::npos ? nextNewLineIdx : fileData.Data.size();

		std::string_view line = std::string_view(fileData.Data.data() + newLineStartIdx, newLineEndIdx - newLineStartIdx);
		return line;
	}

	void FileParser::MoveToEndOfScope(FileParsedData& fileData, const char startScopeChar, const char endScopeChar) const
	{
		size_t scope = 1;
		const size_t scopeStartIdx = fileData.Data.find(startScopeChar, fileData.Cursor) + 1;
		fileData.Cursor = scopeStartIdx;
		while (scope > 0)
		{
			if (fileData.Cursor == fileData.Data.size())
			{
				Log_Error("[FileParser::MoveToEndOfScope] File cursor reached the end of the file '%s'. This should not happen.", fileData.FileName.data());
				Log_Error("Please check that all 'REFLECT_PROPERTY' is correct.\n");
				fileData.AbortParsing = true;
				return;
			}

			const char c = fileData.Data[fileData.Cursor];
			if (c == startScopeChar)
			{
				++scope;
			}
			else if (c == endScopeChar)
			{
				--scope;
			}
			++fileData.Cursor;
		}
	}

	bool FileParser::CheckForTypeAlias(std::string_view view) const
	{
		REFLECT_PROFILE_FUNCTION();
		return view == Keys::TypedefKey 
			|| view == Keys::UsingKey;
	}

	bool FileParser::CheckForVisibility(std::string_view view) const
	{
		REFLECT_PROFILE_FUNCTION();
		return view == Keys::PublicKey 
			|| view == Keys::ProtectedKey 
			|| view == Keys::PrivateKey;
	}

	bool FileParser::CheckForConstructor(FileParsedData& fileData, Parser::ReflectContainerData& container, std::string_view view) const
	{
		REFLECT_PROFILE_FUNCTION();

		size_t i;
		FileParsedData copy = fileData;
		std::string line = GetFunctionLine(copy, i);
		if (line.find('~') != std::string::npos)
		{
			SkipFunctionBody(fileData);
			return true;
		}

		if (view == container.Name || view.at(0) == '~')
		{
			SkipFunctionBody(fileData);
			return true;
		} 
		return false;
	}

	bool FileParser::CheckForIgnoreWord(FileParsedData& fileData, std::string_view view) const
	{
		REFLECT_PROFILE_FUNCTION();

		for (const std::string& str : m_ignoreStrings)
		{
			if (view == str)
			{
				FindNextChar(fileData, ';');
				return true;
			}
		}
		return false;
	}

	bool FileParser::CheckForOperatorFunction(FileParsedData& fileData, std::string_view view) const
	{
		REFLECT_PROFILE_FUNCTION();

		size_t i;
		std::string line = GetFunctionLine(fileData, i);
		size_t index = line.find(Keys::OperatorKey);
		if (index != std::string::npos)
		{
			SkipFunctionBody(fileData);
			return true;
		}
		return false;
	}

	bool FileParser::CheckForComments(FileParsedData& fileData, std::string& line) const
	{
		REFLECT_PROFILE_FUNCTION();

		// Remove all contents of a line with comments.
		size_t index = line.find("//");
		if (index != std::string::npos)
		{
			line = line.substr(0, index);
			FindNextChar(fileData, '\n');
			return true;
		}
		return false;
	}

	bool FileParser::CheckForFriends(FileParsedData& fileData, std::string_view view) const
	{
		REFLECT_PROFILE_FUNCTION();

		if (view == Keys::FriendKey)
		{
			FindNextChar(fileData, ';');
			return true;
		}
		return false;
	}

	uint64_t FileParser::CheckForTemplate(FileParsedData& fileData) const
	{
		// Found out if this class/struct is templated.
		const uint64_t fristSemiColonBeforeTempalte = fileData.Data.rfind(";", fileData.Cursor);
		const uint64_t fristCloseBracketBeforeTempalte = fileData.Data.rfind("}", fileData.Cursor);
		const uint64_t templateIndex = fileData.Data.rfind(Keys::TemplateKey, fileData.Cursor);

		const bool hasTemplate = templateIndex != std::string::npos;
		
		const bool templateValidSemiColon = hasTemplate &&
			(fristSemiColonBeforeTempalte == std::string::npos || templateIndex > fristSemiColonBeforeTempalte);
		
		const bool templateValidCloseBracket = hasTemplate &&
			(fristCloseBracketBeforeTempalte == std::string::npos || templateIndex > fristCloseBracketBeforeTempalte);

		const bool isTempalted = hasTemplate && templateValidSemiColon && templateValidCloseBracket;
		return isTempalted ? templateIndex : -1;
	}

	std::vector<ReflectTemplateData> FileParser::ParseTemplateData(FileParsedData& fileData) const
	{
		std::vector<ReflectTemplateData> reflectedTempalteData;

		const uint64_t templateIndex = fileData.Data.rfind(Keys::TemplateKey, fileData.Cursor);
		if (templateIndex == std::string::npos)
		{
			Log_Error("[FileParser::ParseTemplateData] Was unable to find template.\n");
			return reflectedTempalteData;
		}

		uint64_t templateCursor = templateIndex;
		const uint64_t tempalteStartIndex = fileData.Data.find_first_of("<", templateCursor);
		const uint64_t tempalteEndIndex = FindEndOfTemplate(fileData, tempalteStartIndex);
		assert(tempalteStartIndex < tempalteEndIndex && tempalteEndIndex < fileData.Cursor);

		const std::string_view templateValues = std::string_view(fileData.Data.data() + tempalteStartIndex + 1, tempalteEndIndex - (tempalteStartIndex + 1));
		const std::vector<std::string_view> templateValuesSplit = Util::SplitStringView(templateValues, ',');

		// Process each template argument.
		for (size_t templateValueIndex = 0; templateValueIndex < templateValuesSplit.size(); ++templateValueIndex)
		{
			const std::vector<std::string_view> templateStringSplit = Util::SplitStringView(templateValuesSplit[templateValueIndex], ' ');

			std::string type;
			std::string identifier;
			bool hasDefaultValue = false;
			std::string defaultValue;

			for (size_t templateStringIdx = 0; templateStringIdx < templateStringSplit.size(); ++templateStringIdx)
			{
				std::string_view templateString = templateStringSplit[templateStringIdx];
				if (templateString.empty())
				{
					continue;
				}

				if (hasDefaultValue)
				{
					defaultValue = std::string(templateString.data(), templateString.size());
				}
				else if (templateString == "=")
				{
					hasDefaultValue = true;
				}
				if (!type.empty())
				{
					identifier = std::string(templateString.data(), templateString.size());
				}
				else
				{
					type = std::string(templateString.data(), templateString.size());
				}
			}

			if (!type.empty() && !identifier.empty())
			{
				reflectedTempalteData.emplace_back(ReflectTemplateData(type, identifier, defaultValue));
			}
		}

		return reflectedTempalteData;
	}

	uint64_t FileParser::FindEndOfTemplate(const FileParsedData& fileData, const uint64_t tempalteStartIdx) const
	{
		std::stack<char> templateScopes;
		templateScopes.push('<');

		uint64_t templateCursor = tempalteStartIdx + 1;
		while (templateCursor != fileData.Data.size())
		{
			if (fileData.Data[templateCursor] == '<')
			{
				templateScopes.push('<');
			}
			else if (fileData.Data[templateCursor] == '>')
			{
				templateScopes.pop();
			}

			if (templateScopes.size() == 0)
			{
				break;
			}

			++templateCursor;
		}

		return templateCursor;
	}

	bool FileParser::IsCursorWithinComment(FileParsedData& fileData, uint64_t& cursor, const bool moveCursorToEnd) const
	{
		const uint64_t previousStartBlockIdx = fileData.Data.rfind("/*", cursor);
		const uint64_t previousEndBlockIdx = fileData.Data.rfind("*/", cursor);
		const bool cursorWithinCommentBlock = 
			(previousStartBlockIdx != std::string::npos && previousEndBlockIdx == std::string::npos)
			|| (previousStartBlockIdx != std::string::npos && previousStartBlockIdx > previousEndBlockIdx);

		// Check if the line the cursor is on has an appending '//' to show it has been commented out.

		std::string_view line = GetCurrentLineFromCurosr(fileData, cursor);
		const uint64_t commentLineStartIdx = line.find("//");

		const bool cursorWithinCommentLine = commentLineStartIdx < cursor;

		if (cursorWithinCommentBlock && moveCursorToEnd)
		{
			const uint64_t endOfCommentBlockIdx = fileData.Data.find("*/", cursor);
			cursor = endOfCommentBlockIdx;
		}
		else if (cursorWithinCommentLine && moveCursorToEnd)
		{
			cursor = fileData.Data.find("\n", cursor);
			if (cursor == std::string::npos)
			{
				cursor = fileData.Data.size();
			}
		}

		return cursorWithinCommentBlock || cursorWithinCommentLine;
	}

	void FileParser::GetReflectNameAndReflectValueTypeAndReflectModifer(std::string& str, std::string& name, EReflectValueType& valueType, EReflectValueModifier& modifer) const
	{
		REFLECT_PROFILE_FUNCTION();

		name = Util::Reverse(name);
		Util::RemoveCharAll(name, ' ');
		Util::RemoveString(str, name);

		modifer = CheckForMemberModifers(str);
		Util::RemoveString(str, Keys::ConstKey);
		Util::RemoveString(str, Keys::StaticKey);
		Util::RemoveString(str, Keys::VolatileKey);
		Util::RemoveString(str, Keys::VirtualKey);

		if (str.find('<') == std::string::npos && str.find('>') == std::string::npos)
		{
			valueType = CheckForRefOrPtr(str);
			Util::RemoveCharAll(str, '&');
			Util::RemoveCharAll(str, '*');
		}
		else
		{
			Util::RemoveCharAll(str, ' ');
			std::string stdContainerRefPtr = str.substr(str.find_last_of('>'));
			valueType = CheckForRefOrPtr(stdContainerRefPtr);
		}
	}

	Parser::ReflectFunctionData FileParser::GetFunction(FileParsedData& fileData, const std::vector<std::string>& flags) const
	{
		REFLECT_PROFILE_FUNCTION();

		Parser::ReflectFunctionData functionData;

		size_t endOfLineCursor;
		std::string line = GetFunctionLine(fileData, endOfLineCursor);

		uint32_t cBracket = (uint32_t)line.find_last_of(')');
		size_t functionConst = (uint32_t)line.find(Keys::ConstKey, cBracket);
		if (functionConst != std::string::npos)
		{
			functionData.IsConst = true;
			line = line.substr(0, cBracket + 1);
		}
		uint32_t oBracket = (uint32_t)line.find_first_of('(');
		std::string prameters = line.substr(oBracket, cBracket);
		Util::RemoveString(line, prameters);
		// Parse the parameters.
		functionData.Parameters = ReflectGetFunctionParameters(fileData, prameters);

		// Make sure if there are any spaces between the parameters and the function name we check for them.
		uint32_t cursor = (uint32_t)line.size() - 1;
		while (std::find(emptyChars.begin(), emptyChars.end(), line.at(cursor)) != emptyChars.end())
			--cursor;

		while (std::find(emptyChars.begin(), emptyChars.end(), line.at(cursor)) == emptyChars.end())
		{
			functionData.Name += line.at(cursor);
			--cursor;
		}
		// We should now have just the type.
		// TODO: Think about how to handle 'inline' modifiers and suck.
		// TODO: template support?
		GetReflectNameAndReflectValueTypeAndReflectModifer(line, functionData.Name, functionData.ReflectValueType, functionData.ReflectModifier);

		// Make sure there are no empty chars in the type string.
		for (const char& c : emptyChars)
			Util::RemoveCharAll(line, c);
		functionData.Type = line;

		fileData.Cursor = endOfLineCursor;
		return functionData;
	}

	ReflectMemberData FileParser::GetMember(FileParsedData& fileData, const std::vector<std::string>& flags) const
	{
		REFLECT_PROFILE_FUNCTION();

		ReflectMemberData memberData;
		memberData.TypeSize = DEFAULT_TYPE_SIZE;
		memberData.ContainerProps = flags;

		FileParsedData copy = fileData;
		FindNextChar(copy, ';');
		std::string line = fileData.Data.substr(fileData.Cursor, copy.Cursor - fileData.Cursor);
		size_t endOfLineCursor = fileData.Cursor + (size_t)line.size();
		line += ';';

		// Check for if there is a deault value being set.
		uint32_t equalCursor = (uint32_t)line.find('=');
		uint32_t semicolonCursor = (uint32_t)line.find(';');
		uint32_t cursor = equalCursor < semicolonCursor ? equalCursor : semicolonCursor;

		// Always go back one so we are not on '=' or ';';
		--cursor;
		// Go back untill we are not on an empty char.
		while (std::find(emptyChars.begin(), emptyChars.end(), line.at(cursor)) != emptyChars.end())
			--cursor;
		line = line.substr(0, cursor + 1);

		// 'line' should now contain the value, member name and any modifers like const.
		std::vector<char> endChars = emptyChars;
		endChars.push_back('*');
		endChars.push_back('&');
		while (std::find(endChars.begin(), endChars.end(), line.at(cursor)) == endChars.end())
		{
			memberData.Name += line.at(cursor);
			--cursor;
		}
		GetReflectNameAndReflectValueTypeAndReflectModifer(line, memberData.Name, memberData.ReflectValueType, memberData.ReflectModifier);

		cursor = (uint32_t)line.size() - 1;
		while (std::find(emptyChars.begin(), emptyChars.end(), line.at(cursor)) != emptyChars.end())
			--cursor;
		std::string type = line.substr(0, cursor + 1);

		// Make sure there are no empty chars in the type string.
		for (const char& c : emptyChars)
			Util::RemoveCharAll(type, c);

		const uint64_t templateStart = type.find('<');
		const uint64_t templateEnd = type.find('>');
		if (templateStart != std::string::npos
			&& templateEnd != std::string::npos)
		{
			memberData.IsTemplate = true;
			memberData.TemplateFirstType = type.substr(0, templateStart);
			memberData.TemplateSecondType = type.substr(templateStart + 1, (templateEnd - templateStart) - 1);
		}
		memberData.Type = type;

		memberData.RawType = type;

		fileData.Cursor = endOfLineCursor;
		return memberData;
	}

	void FileParser::SkipFunctionBody(FileParsedData& fileData) const
	{
		REFLECT_PROFILE_FUNCTION();

		FileParsedData bracketCursor = fileData;
		FindNextChar(bracketCursor, '{');
		FileParsedData semicolonCursor = fileData;
		FindNextChar(semicolonCursor, ';');

		if (semicolonCursor.Cursor < bracketCursor.Cursor)
		{
			fileData.Cursor = semicolonCursor.Cursor;
			return;
		}
		fileData.Cursor = bracketCursor.Cursor;

		std::stack<char> brackets;
		char c = fileData.Data[fileData.Cursor];
		while (true)
		{
			if (c == '{')
				brackets.push('{');
			else if (c == '}')
				brackets.pop();

			if (brackets.size() == 0)
			{
				break;
			}
			c = fileData.Data[++fileData.Cursor];
		}
	}

	EReflectType FileParser::CheckForReflectType(FileParsedData& data) const
	{
		REFLECT_PROFILE_FUNCTION();

		auto find_closest_char = [data, this](std::vector<char> const& chars_to_find)
		{
			size_t cursor = INT_MAX;
			for (size_t i = 0; i < chars_to_find.size(); ++i)
			{
				char charToFind = chars_to_find.at(i);
				FileParsedData copy = data;
				FindNextChar(copy, charToFind);
				cursor = std::min(copy.Cursor, cursor);
			}
			return cursor;
		};

		FileParsedData copy = data;
		size_t scope = 0;
		while (scope > 0)
		{
			assert(true);
		}

		size_t member_cursor = find_closest_char(memberStartChars);
		size_t function_cursor = find_closest_char(functionStartChars);

		bool isTemplate = data.Data.find(Keys::TemplateKey, data.Cursor) < member_cursor;

		if (member_cursor < function_cursor && !isTemplate)
		{
			return EReflectType::Member;
		}
		else if (function_cursor != INT_MAX && !isTemplate)
		{
			return EReflectType::Function;
		}

		if (isTemplate)
		{
			SkipFunctionBody(data);
		}
		return EReflectType::Unknown;
	}

	bool FileParser::CheckForEndOfFile(FileParsedData& fileData, size_t cursor) const
	{
		REFLECT_PROFILE_FUNCTION();

		if (fileData.Cursor >= cursor)
		{
			return true;
		}

		FileParsedData copy = fileData;
		char c = copy.Data[copy.Cursor];
		bool endOfFile = false;
		char previousValidChar = c;
		while (copy.Cursor < cursor)
		{
			++copy.Cursor;
			c = copy.Data[copy.Cursor];
			if (std::find(emptyChars.begin(), emptyChars.end(), c) == emptyChars.end())
			{
				if (previousValidChar == '}')
				{
					endOfFile = c == ';';
				}
				break;
			}
		}
		if (endOfFile)
			fileData.Cursor = ++copy.Cursor;
		return endOfFile || copy.Cursor == cursor;
	}

	EReflectValueType FileParser::CheckForRefOrPtr(std::string_view view) const
	{
		REFLECT_PROFILE_FUNCTION();

		size_t referenceIndex = view.find(Keys::ReferenceKey);
		size_t pointerIndex = view.find(Keys::PointerKey);

		// Get the type. We need this as the code generation will need to add some casting 
		// if the type is not a value.
		if (referenceIndex == std::string::npos && pointerIndex == std::string::npos)
			return EReflectValueType::Value;
		else if (referenceIndex < pointerIndex)
			return EReflectValueType::Reference;
		else if (pointerIndex < referenceIndex && referenceIndex == std::string::npos)
			return EReflectValueType::Pointer;
		else if (pointerIndex < referenceIndex && referenceIndex != std::string::npos)
			return EReflectValueType::PointerReference;
		// TODO: Think about pointer, pointer, pointer, etc. 
		assert(false && "[FileParser::CheckForRefOrPtr] Unknow type.");
		return EReflectValueType::Value;
	}

	EReflectValueModifier FileParser::CheckForMemberModifers(std::string_view view) const
	{
		REFLECT_PROFILE_FUNCTION();

		size_t constIndex = view.find(Keys::ConstKey);
		size_t staticIndex = view.find(Keys::StaticKey);
		size_t volatileIndex = view.find(Keys::VolatileKey);
		size_t virtualIndex = view.find(Keys::VirtualKey);

		if (constIndex != std::string::npos)
			return EReflectValueModifier::Const;
		else if (staticIndex != std::string::npos)
			return EReflectValueModifier::Static;
		else if (volatileIndex != std::string::npos)
			return EReflectValueModifier::Volatile;
		else if (virtualIndex != std::string::npos)
			return EReflectValueModifier::Virtual;

		//TODO: Think about const static
		return EReflectValueModifier::None;
	}

	std::string FileParser::GetFunctionLine(const FileParsedData& fileData, size_t& endCursor) const
	{
		REFLECT_PROFILE_FUNCTION();

		FileParsedData copy = fileData;
		FindNextChar(copy, ';');
		endCursor = copy.Cursor;
		copy = fileData;
		FindNextChar(copy, '{');
		if (copy.Cursor < endCursor)
		{
			SkipFunctionBody(copy);
			endCursor = copy.Cursor;
		}
		else
		{
			endCursor = std::min(copy.Cursor, endCursor);
		}
		return fileData.Data.substr(fileData.Cursor, endCursor - fileData.Cursor);
	}

	std::vector<Parser::ReflectTypeNameData> FileParser::ReflectGetFunctionParameters(const FileParsedData& fileData, std::string_view view) const
	{
		REFLECT_PROFILE_FUNCTION();

		size_t cursor = 0;
		if (view.at(0) == '(')
			++cursor;

		std::vector<Parser::ReflectTypeNameData> parameters;
		std::string str;
		char c = view.at(cursor);
		while (cursor < view.size())
		{
			if (c != ',' && c != ')')
				str += c;
			else
			{
				if (str.size() > 0 && !Util::StringContains(str, emptyChars))
				{
					Parser::ReflectTypeNameData parameter;

					std::size_t defaultValueIndex = str.find('=');
					if (defaultValueIndex != std::string::npos)
					{
						cursor = (size_t)(((size_t)view.size() - 1) - (size_t)str.size()) + (size_t)defaultValueIndex;
					}

					// Extract the name, type for the parameter.
					size_t copyCursor = cursor - 1;
					while (std::find(emptyChars.begin(), emptyChars.end(), view.at(copyCursor)) != emptyChars.end())
						--copyCursor;

					while (std::find(emptyChars.begin(), emptyChars.end(), view.at(copyCursor)) == emptyChars.end())
					{
						parameter.Name += view.at(copyCursor);
						--copyCursor;
						CheckStringViewBounds(fileData, copyCursor, view);
					}
					GetReflectNameAndReflectValueTypeAndReflectModifer(str, parameter.Name, parameter.ReflectValueType, parameter.ReflectModifier);

					while (view.at(copyCursor) != '(' && view.at(copyCursor) != ',')
					{
						parameter.Type += view.at(copyCursor);
						--copyCursor;
						CheckStringViewBounds(fileData, copyCursor, view);
					}
					parameter.Type = Util::Reverse(parameter.Type);
					Util::RemoveCharReverse(parameter.Type, Keys::ReferenceKey);
					Util::RemoveCharReverse(parameter.Type, Keys::PointerKey);

					parameter.RawType = parameter.Type;
					Util::RemoveString(parameter.RawType, Keys::ConstKey);
					Util::RemoveCharAll(parameter.RawType, Keys::WhiteSpaceKey);

					str = {};
					parameters.push_back(parameter);
				}
				if (c == ')')
				{
					break;
				}
			}
			++cursor;
			c = view.at(cursor);
			//auto [type, name, isConst] = ReflectTypeAndName(fileData, { ',', ')' });
			//parameters.push_back(
			//	{
			//		type,
			//		name,
			//		DEFAULT_TYPE_SIZE,
			//		type.back() == '*' || type.back() == '&' ? (type.back() == '*' ? EReflectValueType::Pointer : EReflectValueType::Reference) : EReflectValueType::Value,
			//		isConst
			//	});
		}
		return parameters;
	}

	void FileParser::CheckStringViewBounds(const FileParsedData& fileData, size_t cursor, std::string_view view) const
	{
		REFLECT_PROFILE_FUNCTION();

		if (cursor < 0 || cursor >= view.size())
		{
			Log_Error("[FileParser::CheckStringViewBounds] File: '%s', Line: '%s', Cursor: '%d'.\n", fileData.FileName.data(), view.data(), cursor);
			exit(0);
		}
	}

	size_t FileParser::CountNumberOfSinceTop(const FileParsedData& fileData, size_t cursorStart, const char& character) const
	{
		REFLECT_PROFILE_FUNCTION();

		size_t count = 0;
		while (cursorStart > 0)
		{
			//TODO Out of bounds checks.
			if (fileData.Data[cursorStart] == character)
			{
				++count;
			}
			--cursorStart;
		}
		return count;
	}

	std::string FileParser::PrettyString(std::string str) const
	{
		REFLECT_PROFILE_FUNCTION();

		std::replace(str.begin(), str.end(), '_', ' ');
		for (size_t i = 1; i < str.size(); ++i)
		{
			if (isupper(str[i]))
			{
				str.insert(str.begin() + i, ' ');
				++i;
			}
		}
		return str;
	}

	ReflectContainerData* FileParser::FindReflectContainerData(std::string_view containerName)
	{
		const ReflectContainerData* reflectData = const_cast<const FileParser*>(this)->FindReflectContainerData(containerName);
		return const_cast<ReflectContainerData*>(reflectData);
	}

	const ReflectContainerData* FileParser::FindReflectContainerData(std::string_view containerName) const
	{
		for (const FileParsedData& file : m_filesParsed)
		{
			for (const ReflectContainerData& reflectedData : file.ReflectData)
			{
				std::vector<std::string> compareNames = { std::string(containerName) };
				if (auto iter = TypeAliasMap.find(compareNames[0]);
					iter != TypeAliasMap.end())
				{
					std::copy(iter->second.begin(), iter->second.end(), std::back_inserter(compareNames));
				}

				for (size_t i = 0; i < compareNames.size(); i++)
				{
					const std::string compareName = compareNames[i];
					if (reflectedData.Name == compareName)
					{
						return &reflectedData;
					}

					std::vector<std::string> reflectDataSplit = Util::SplitString(reflectedData.NameWithNamespace, (char)'::');
					std::vector<std::string> containerNameSplit = Util::SplitString(std::string(compareName), (char)'::');

					if (reflectDataSplit.empty())
					{
						continue;
					}

					std::reverse(reflectDataSplit.begin(), reflectDataSplit.end());
					std::reverse(containerNameSplit.begin(), containerNameSplit.end());

					const size_t endNamespaceIdx = std::min(containerNameSplit.size(), reflectDataSplit.size());

					bool foundReflectData = true;
					for (size_t i = 0; i < endNamespaceIdx; ++i)
					{
						if (containerNameSplit[i] != reflectDataSplit[i])
						{
							foundReflectData = false;
							break;
						}
					}

					if (foundReflectData)
					{
						return &reflectedData;
					}
				}
			}
		}
		return nullptr;
	}

	std::string FileParser::FindFullAliasName(const std::string& aliasName) const
	{
		// We've tried comparing the name as is to complete containers. The name specified might be an alias (using/typedef)
		if (auto iter = TypeAliasMap.find(aliasName);
			iter != TypeAliasMap.end())
		{
			if (iter->second.size() == 1)
			{
				return iter->second[0];
			}
			else
			{
				Log_Warn("[FileParser::FindFullAliasName] Unable to get full name for alias of '%s' as there is more than on possible result.\n", aliasName);
			}
		}

		return "";
	}
}